<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>RPS.bot: Intro – RPS.bot</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="././assets/logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6GK6C5LZSG"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6GK6C5LZSG', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="RPS.bot: Intro – RPS.bot">
<meta property="og:description" content="">
<meta property="og:site_name" content="RPS.bot">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="././assets/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">RPS.bot</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://overbet.ai"> 
<span class="menu-text">Overbet.ai</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://discord.gg/KZQK2xN8Da" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-discord"></i></a>
    <a href="https://overbetai.substack.com/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-mailbox2-flag"></i></a>
    <a href="https://github.com/overbetai/cardstocode" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <h1 class="quarto-secondary-nav-title no-breadcrumbs">RPS.bot: Intro</h1>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Intro to RPS</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rpstheory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RPS Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rpsom.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RPS Opponent Modeling</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./rpsbotchallenge.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RPS Bot Challenge</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#how-it-works" id="toc-how-it-works" class="nav-link active" data-scroll-target="#how-it-works">How it Works</a></li>
  <li><a href="#why" id="toc-why" class="nav-link" data-scroll-target="#why">Why?</a></li>
  <li><a href="#game-theory-equilibrium" id="toc-game-theory-equilibrium" class="nav-link" data-scroll-target="#game-theory-equilibrium">Game Theory Equilibrium</a>
  <ul class="collapse">
  <li><a href="#payoff-matrix" id="toc-payoff-matrix" class="nav-link" data-scroll-target="#payoff-matrix">Payoff matrix</a></li>
  <li><a href="#expected-value" id="toc-expected-value" class="nav-link" data-scroll-target="#expected-value">Expected value</a></li>
  <li><a href="#zero-sum" id="toc-zero-sum" class="nav-link" data-scroll-target="#zero-sum">Zero-sum</a></li>
  <li><a href="#nash-equilibrium" id="toc-nash-equilibrium" class="nav-link" data-scroll-target="#nash-equilibrium">Nash equilibrium</a></li>
  <li><a href="#exploiting-vs.-nash" id="toc-exploiting-vs.-nash" class="nav-link" data-scroll-target="#exploiting-vs.-nash">Exploiting vs.&nbsp;Nash</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">RPS.bot: Intro</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="how-it-works" class="level2">
<h2 class="anchored" data-anchor-id="how-it-works">How it Works</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rps.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Image by <a href="https://en.wikipedia.org/wiki/Rock_paper_scissors#/media/File:Rock-paper-scissors.svg">Enzoklop</a> under <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a></figcaption>
</figure>
</div>
<ul>
<li>Rock defeats scissors, scissors defeats paper, and paper defeats rock</li>
<li>You get +1 point for a win, -1 for a loss, and 0 for ties</li>
</ul>
</section>
<section id="why" class="level2">
<h2 class="anchored" data-anchor-id="why">Why?</h2>
<p>We think RPS is fun and while simple enough that everyone knows it and understands the rules, it’s still a great domain for thinking about strategy in a repeated game against a variety of opponents.</p>
<p>From DeepMind in 2023:</p>
<blockquote class="blockquote">
<p>In sequential decision-making, agent evaluation has largely been restricted to few interactions against experts, with the aim to reach some desired level of performance (e.g.&nbsp;beating a human professional player). We propose a benchmark for multiagent learning based on repeated play of the simple game Rock, Paper, Scissors.</p>
</blockquote>
</section>
<section id="game-theory-equilibrium" class="level2">
<h2 class="anchored" data-anchor-id="game-theory-equilibrium">Game Theory Equilibrium</h2>
<section id="payoff-matrix" class="level3">
<h3 class="anchored" data-anchor-id="payoff-matrix">Payoff matrix</h3>
<p>The core features of a game are its players, the actions of each player, and the payoffs. We can show this for RPS in the below payoff matrix, also known as normal-form.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Player 1/2</th>
<th>Rock</th>
<th>Paper</th>
<th>Scissors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rock</strong></td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
</tr>
<tr class="even">
<td><strong>Paper</strong></td>
<td>(1, -1)</td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
</tr>
<tr class="odd">
<td><strong>Scissors</strong></td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
<td>(0, 0)</td>
</tr>
</tbody>
</table>
<p>The <strong>payoffs</strong> for Player 1 are on the left and for Player 2 on the right in each payoff outcome of the game. For example, the bottom left payoff is when Player 1 plays Scissors and Player 2 plays Rock, resulting in -1 for P1 and +1 for P2.</p>
<p>A <strong>strategy</strong> says which actions you would take for every state of the game.</p>
</section>
<section id="expected-value" class="level3">
<h3 class="anchored" data-anchor-id="expected-value">Expected value</h3>
<p><strong>Expected value</strong> in a game represents the average outcome of a strategy if it were repeated many times. It’s calculated by multiplying each possible outcome by its probability of occurrence and then summing these products.</p>
<p>Suppose that Player 1 plays the strategy:</p>
<p><span class="math display">
\begin{cases}
r_1 = 0.5 \\
p_1 = 0.25 \\
s_1 = 0.25
\end{cases}
</span></p>
<p>and Player 2 plays the strategy:</p>
<p><span class="math display">
\begin{cases}
r_2 = 0.1 \\
p_2 = 0.3 \\
s_2 = 0.6
\end{cases}
</span></p>
<p>Let’s add these to the matrix:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Player 1/2</th>
<th>Rock (<span class="math inline">r_2=0.1</span>)</th>
<th>Paper (<span class="math inline">p_2=0.3</span>)</th>
<th>Scissors (<span class="math inline">s_2=0.6</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rock (<span class="math inline">r_1=0.5</span>)</strong></td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
</tr>
<tr class="even">
<td><strong>Paper (<span class="math inline">p_1=0.25</span>)</strong></td>
<td>(1, -1)</td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
</tr>
<tr class="odd">
<td><strong>Scissors (<span class="math inline">s_1=0.25</span>)</strong></td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
<td>(0, 0)</td>
</tr>
</tbody>
</table>
<p>To simplify, let’s just write the payoffs for Player 1 since payoffs for Player 2 will simply be the opposite:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Player 1/2</th>
<th>Rock (<span class="math inline">r_2=0.1</span>)</th>
<th>Paper (<span class="math inline">p_2=0.3</span>)</th>
<th>Scissors (<span class="math inline">s_2=0.6</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rock (<span class="math inline">r_1=0.5</span>)</strong></td>
<td>0</td>
<td>-1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>Paper (<span class="math inline">p_1=0.25</span>)</strong></td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td><strong>Scissors (<span class="math inline">s_1=0.25</span>)</strong></td>
<td>-1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Now we can multiply the player action strategies together to get a percentage occurrence for each payoff in the matrix:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Player 1/2</th>
<th>Rock (<span class="math inline">r_2=0.1</span>)</th>
<th>Paper (<span class="math inline">p_2=0.3</span>)</th>
<th>Scissors (<span class="math inline">s_2=0.6</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rock (<span class="math inline">r_1=0.5</span>)</strong></td>
<td>Val: 0 <br>Pr: <span class="math inline">0.5(0.1) = .05</span></td>
<td>Val: -1 <br>Pr: <span class="math inline">0.5(0.3) = .15</span></td>
<td>Val: 1 <br>Pr: <span class="math inline">0.5(0.6) = .3</span></td>
</tr>
<tr class="even">
<td><strong>Paper (<span class="math inline">p_1=0.25</span>)</strong></td>
<td>Val: 1 <br>Pr: <span class="math inline">0.25(0.1) = .025</span></td>
<td>Val: 0 <br>Pr: <span class="math inline">0.25(0.3) = .075</span></td>
<td>Val: -1 <br>Pr: <span class="math inline">0.25(0.6) = .15</span></td>
</tr>
<tr class="odd">
<td><strong>Scissors (<span class="math inline">s_1=0.25</span>)</strong></td>
<td>Val: -1 <br>Pr: <span class="math inline">0.25(0.1) = .025</span></td>
<td>Val: 1 <br>Pr: <span class="math inline">0.25(0.3) = .075</span></td>
<td>Val: 0 <br>Pr: <span class="math inline">0.25(0.6) = .15</span></td>
</tr>
</tbody>
</table>
<p>Note that the total probabilities sum to 1 and each row and column sums to the probability of playing that row or column.</p>
<p>We can work out the expected value of the game to Player 1 (summing all payoffs multiplied by probabilities from top left to bottom right):</p>
<p><span class="math inline">\mathbb{E}[P_1] = 0(0.05) + -1(0.15) + 1(0.3) + 1(0.025) + 0(0.075) + -1(0.15) + -1(0.025) + 1(0.075) + 0(0.15) = 0.075</span></p>
<p>Therefore P1 is <em>expected</em> to gain 0.075 per game given these strategies. Since payoffs are reversed for P2, P2’s expectation is -0.075 per game.</p>
</section>
<section id="zero-sum" class="level3">
<h3 class="anchored" data-anchor-id="zero-sum">Zero-sum</h3>
<p>We see in the matrix that every payoff is zero-sum, i.e.&nbsp;the sum of the payoffs to both players is 0. This means the game is one of pure competition. Any amount P1 wins is from P2 and vice versa.</p>
</section>
<section id="nash-equilibrium" class="level3">
<h3 class="anchored" data-anchor-id="nash-equilibrium">Nash equilibrium</h3>
<p>A Nash equilibrium means that no player can improve their expected payoff by unilaterally changing their strategy. That is, changing one’s strategy can only result in the same or worse payoff (assuming the other player does not change).</p>
<p>In RPS, the Nash equilibrium strategy is to play each action <span class="math inline">r = p = s = 1/3</span> of the time. I.e., to play totally randomly.</p>
<p>Playing a combination of strategies is called a mixed strategy, as opposed to a pure strategy, which would select only one action. Mixed strategies are useful in games of imperfect information because it’s valuable to not be predictable and to conceal your private information. In perfect information games, the theoretically optimal play would not contain any mixing (i.e., if you could calculate all possible moves to the end of the game).</p>
<p>The equilibrium RPS strategy is worked out below:</p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nash equilibrium strategy for RPS
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<table class="caption-top table">
<thead>
<tr class="header">
<th>Player 1/2</th>
<th>Rock</th>
<th>Paper</th>
<th>Scissors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rock (<span class="math inline">r</span>)</strong></td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
</tr>
<tr class="even">
<td><strong>Paper (<span class="math inline">p</span>)</strong></td>
<td>(1, -1)</td>
<td>(0, 0)</td>
<td>(-1, 1)</td>
</tr>
<tr class="odd">
<td><strong>Scissors (<span class="math inline">s</span>)</strong></td>
<td>(-1, 1)</td>
<td>(1, -1)</td>
<td>(0, 0)</td>
</tr>
</tbody>
</table>
<p>If Player 1 plays Rock with probability <span class="math inline">r</span>, Paper with probability <span class="math inline">p</span>, and Scissors with probability <span class="math inline">s</span>, we have the following expected value equations for Player 2:</p>
<p><span class="math inline">\mathbb{E}[P_2(R)] = 0r -1p + 1s</span></p>
<p><span class="math inline">\mathbb{E}[P_2(P)] = 1r + 0p - 1s</span></p>
<p><span class="math inline">\mathbb{E}[P_2(S)] = -1r + 1p + 0s</span></p>
<p>(To compute each of these, sum the payoffs for each column with P2 payoffs and P1 probabilities. P2 payoffs because we are calculating the expected payoffs for P2 and P1 probabilities because the payoffs depend on the strategy probabilties of P1 against each of P2’s actions.)</p>
<p>Since no action dominates, we know that the EV of every strategic action should be equal (since if a certain strategy was best, we’d want to always play that strategy).</p>
<p>To solve for <span class="math inline">r</span>, <span class="math inline">p</span>, and <span class="math inline">s</span>, we can start by setting these EVs equal:</p>
<p><span class="math inline">\mathbb{E}[P_2(R)] = \mathbb{E}[P_2(P)]</span></p>
<p><span class="math inline">-1p + 1s = 1r - 1s</span></p>
<p><span class="math inline">2s = p + r</span></p>
<p>Then setting these equal:</p>
<p><span class="math inline">\mathbb{E}[P_2(R)] = \mathbb{E}[P_2(S)]</span></p>
<p><span class="math inline">-1p + 1s = -1r + 1p</span></p>
<p><span class="math inline">s + r = 2p</span></p>
<p>And finally setting these equal:</p>
<p><span class="math inline">\mathbb{E}[P_2(P)] = \mathbb{E}[P_2(S)]</span></p>
<p><span class="math inline">1r - 1s = -1r + 1p</span></p>
<p><span class="math inline">2r = s + p</span></p>
<p>Now we have these equations:</p>
<p><span class="math display">
\begin{cases}
2s = p + r \\
s + r = 2p \\
2r = s + p
\end{cases}
</span></p>
<p>We can rewrite the 1st:</p>
<p><span class="math inline">r = 2s - p</span></p>
<p>And combine with the 2nd:</p>
<p><span class="math inline">s + (2s - p) = 2p</span></p>
<p><span class="math inline">3s = 3p</span></p>
<p>Resulting in:</p>
<p><span class="math inline">s = p</span></p>
<p>Now we can go back to the 2nd equation:</p>
<p><span class="math inline">s + r = 2p</span></p>
<p>And insert <span class="math inline">s</span> = <span class="math inline">p</span>:</p>
<p><span class="math inline">s + r = 2s</span></p>
<p>And arrive at:</p>
<p><span class="math inline">r = s</span></p>
<p>We now see that all are equal:</p>
<p><span class="math inline">s = p = r</span></p>
<p>We also know that they must all sum to <span class="math inline">1</span>:</p>
<p><span class="math inline">r + p + s = 1</span></p>
<p>Since they’re all equal and sum to <span class="math inline">1</span>, we can substitute <span class="math inline">p</span> and <span class="math inline">s</span> with <span class="math inline">r</span>:</p>
<p><span class="math inline">3r = 1</span></p>
<p><span class="math inline">r = 1/3</span></p>
<p>So all actions are taken with probability <span class="math inline">1/3</span>:</p>
<p><span class="math inline">r = p = s = 1/3 \quad \blacksquare</span></p>
<p>By symmetry, the same equilibrium strategy is true for Player 2.</p>
</div>
</div>
</div>
<p>Playing this strategy means that whatever your opponent does, you will breakeven! For example, think about an opponent that always plays Rock.</p>
<p><span class="math display">
\begin{equation}
\begin{split}
\mathbb{E}(\text{Equilibrium vs. Rock}) &amp;= 0(r) + 1(p) + -1(s) \\
&amp;= 0(1/3) + 1(1/3) + -1(1/3) \\
&amp;= 0
\end{split}
\end{equation}
</span></p>
<p>How about the case of the opponent playing 60% Rock, 20% Paper, 20% Scissors?</p>
<p><span class="math display">
\begin{equation}
\begin{split}
\mathbb{E}(\text{Equilibrium vs. 622}) &amp;= 0.6(\text{Equilibrium vs. Rock}) \\
&amp;\quad{}+ 0.2(\text{Equilibrium vs. Paper}) \\  
&amp;\quad{}+ 0.2(\text{Equilibrium vs. Scissors}) \\
&amp;= 0.6(0) + 0.2(0) + 0.2(0) \\
&amp;= 0
\end{split}
\end{equation}
</span></p>
<p>The random equilibrium strategy will result in 0 against any pure strategy and any combination of strategies including <em>622</em> and the opponent playing the random strategy.</p>
</section>
<section id="exploiting-vs.-nash" class="level3">
<h3 class="anchored" data-anchor-id="exploiting-vs.-nash">Exploiting vs.&nbsp;Nash</h3>
<p>The equilibrium strategy vs.&nbsp;a pure Rock opponent is a useful illustration of the limitations of playing at equilibrium. The Rock opponent is playing the worst possible strategy, yet equilibrium is still breaking even!</p>
<p>What’s the best that we could do against Rock only? We could play <strong>purely paper</strong>. This is called a <strong>best response</strong> strategy. The payoffs are written for playing Paper and the probabilities indicate the opponent playing only Rock.</p>
<p><span class="math display">
\begin{equation}
\begin{split}
\mathbb{E}(\text{Paper vs. Rock}) &amp;= 1(r) + 0(p) + -1(s) \\
&amp;= 1(1) + 0(0) + -1(0) \\
&amp;= 1
\end{split}
\end{equation}
</span></p>
<p>We’d win 1 each game playing Paper vs.&nbsp;Rock.</p>
<p>How about against the opponent playing 60% Rock, 20% Paper, 20% Scissors? Here we can see that because they are overplaying Rock, our best strategy is again to always play Paper. We write the payoffs for playing Paper and the probabilities according to the <em>622</em> strategy.</p>
<p><span class="math display">
\begin{equation}
\begin{split}
\mathbb{E}(\text{Paper vs. 622}) &amp;= 1(r) + 0(p) + -1(s) \\
&amp;= 1(0.6) + 0(0.2) + -1(0.2) \\
&amp;= 0.6 + 0 - 0.2 \\
&amp;= 0.4
\end{split}
\end{equation}
</span></p>
<p>Playing Paper vs.&nbsp;<em>622</em> results in an expected win of 0.4 per game.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2024 Overbet.ai. All rights reserved.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>